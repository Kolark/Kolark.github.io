{"pageProps":{"page":{"shaders":[{"groupProps":{"position":[-8.25,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"a","model":"A_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    newPos.y += sin(time*5.0 + position.z*cos(time*0.25)*0.25)*5.5;\n\n    // newPos.x += cos(time*10.0 + position.y*sin(time*1.5))*0.5;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color = vec3(newUv.y,(sin(time)+1.0)*0.5,0.5);\n    gl_FragColor = vec4(color,1.0);\n}"},{"groupProps":{"position":[-6.25,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"b","model":"B_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    newPos.xy += vec2(sin(distance(vec2(0.5),newPos.yz)*cos(time*.5)+ time* 8.),0.0);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvoid main() {\n    vec2 newUv = vUv;\n\n    gl_FragColor = vec4(newUv.x,newUv.y,0.0,1.0);\n}"},{"groupProps":{"position":[-4.25,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"c","model":"C_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvoid main() {\n    vUv = uv;\n    vec3 newPos = position;\n    vec3 dif = normalize(newPos - vec3(sin(time*5.),cos(time*5.),0));\n    vec3 dotCalc = dif*sin(newPos.x*dif.z*(cos(time)*0.5) + time*10.)*4.5;\n    \n    vec3 finalPos = newPos + dotCalc;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvoid main() {\n    vec2 newUv = vUv;\n    float dist = distance(newUv,vec2(0));\n    float a = abs(sin(dist*2.5+time));\n    float b = abs(cos(dist*1.5+time));\n    float c = (cos(time)+1.0)/2.0;\n    vec3 finalColor = vec3(a,b,c);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-2.25,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"d","model":"D_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vStepValue;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n\n    float pos = (sin(time*10.0)+1.0)/2.0;\n\n    vec3 diff = normalize(newPos - vec3(0.0));\n\n    vec3 stepValue = vec3(map(sin(time*1.5),-1.0,1.0,0.0,1.0));\n    vStepValue = stepValue;\n    diff = step(stepValue,diff);\n    vec3 finalPos = newPos + diff*sin(time*3.5)*50.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vStepValue;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color1 = vec3(newUv.yx,1.0);\n    vec3 rgbColor1 = hsb2rgb(color1);\n    float a = (sin((vStepValue.x+newUv.y) *2.0)+1.0)/2.0;\n\n    float positiveSine = ((sin(time*5.0)+1.0)/2.0);\n\n    vec3 finalColor = vec3(mod(rgbColor1.xy,positiveSine*5.0),smoothstep(0.25,0.75,a));\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-0.25,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"e","model":"E_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vDiff;\nuniform float time;\nvoid main() {\n    vUv = uv;\n    vec3 newPos = position;\n    newPos -= vec3(50.,0.0,-50.);\n    newPos*= 1.5;\n\n    vec2 diff = newPos.xz - vec2(75.,-35.);\n    vDiff = diff;\n    vec3 finalPos = newPos;\n    float smoothl = 15.;\n    float value = smoothstep(length(diff)-smoothl,length(diff)+smoothl,90. + sin(time)*45.);\n    finalPos.y += sin(value*15.)*15.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying vec2 vDiff;\nvoid main() {\n    vec2 newUv = vUv;\n    newUv -= vec2(0.5,0.5);\n\n    float stValue = (sin(time)+1.0)*0.5;\n    float v1 = smoothstep(stValue-0.15,stValue+0.15,length(newUv));\n    float v2 = (sin(length(newUv)*10.*cos(time*1.5)+time)+1.0)*0.5;\n    gl_FragColor = vec4(vec3(v1,v2,mod(0.5,vUv.x)),1.0);\n}"},{"groupProps":{"position":[1.75,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"f","model":"F_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vYValue;\nvarying float vSmSt;\nuniform float time;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n    vec3 newPos = position;\n\n    vec2 ref = newPos.xz;\n    ref.x += cos(time*5.)*15.;\n    ref.y += sin(time*5.)*15.;\n\n    vec2 diff = ref - vec2(75.,-75.);\n\n    float yValue = sin(length(diff)*0.5 + time*10.0)*5.0 - length(diff)*sin(time*10.)*0.15;\n    vYValue = yValue;\n\n    float s = smoothstep((50.+sin(time*1.75)*50.)-3.,(50.+sin(time*1.75)*50.)+3.,newPos.x);\n    vSmSt = s;\n    newPos.y += s*yValue;\n\n    vec3 finalPos = newPos;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}\n\n// void main() {\n//     vUv = uv;\n//     vec3 newPos = position;\n\n//     vec2 ref = newPos.xz;\n//     ref.x += cos(time*5.)*15.;\n//     ref.y += sin(time*5.)*15.;\n\n//     vec2 diff = ref - vec2(75.,-75.);\n//     vec3 newPosNormalized = normalize(newPos);\n\n//     float yValue = sin(length(diff)*0.5 + time*10.0)*5.0 - length(diff)*sin(time*10.)*0.15;\n\n//     float v1 = mod(1.+sin(time*1.75)*1.,newPos.x)*1.5;\n//     float v2 = step(50.+sin(time*1.75)*50.,newPos.x)*1.5;\n//     newPos.y += smoothstep(0.,1.,mix(v1,v2,abs(newPosNormalized.z)))*yValue;\n\n//     vec3 finalPos = newPos;\n\n//     gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n// }","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vYValue;\nvarying float vSmSt;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec2 diff = newUv - vec2(sin(time*5.)*0.15 +.5,cos(time*5.)*0.15 + .5);\n\n    float a=length(diff)*sinTMap(1.5,0.05,0.25)*vYValue;\n    float b=newUv.y*sinTMap(newUv.x*80.5,cos(time),1.);\n    float c=cosTMap(2.5*mod(newUv.x,time),0.0,1.0);\n    vec3 col = vec3(a,c*b,b);\n    float w1=sinTMap(2.5,0.0,1.0)*newUv.y;\n    float w2=(dot(vec2(sin(time*2.5),cos(time*2.5)),newUv)+1.0)*0.5;\n    float w3=length(newUv)*newUv.x;\n    vec3 w = vec3(w2,w1,w3);\n    vec3 finalColor = mix(w,col,vSmSt);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[3.75,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"g","model":"G_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n//(x,y) : x = r × cos( θ ) y = r × sin( θ )\n// float x = r*cos(deg)\n// float y = r*sin(deg)\n\n//r = √ ( x2 + y2 ) r= length(vecotr)\n//θ = tan-1 ( y / x ) deg = atan(y/x)\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 diff = vec2(75.,-75.) - newPos.xz;\n\n    float r = length(diff);\n    float deg = atan(diff.y,diff.x);\n    float f = sin(10.*deg + time*3.);\n\n    vR = r;\n    vDeg = deg;\n    vF = f;\n\n    vec3 finalPos = newPos+vec3(0.,1.,0.)*smoothstep(0.25,0.75,f)*25.0*sinTMap(0.5,0.0,1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color1 = vec3(newUv.y*vR*0.05,(vF+1.0)*0.5,newUv.y);\n    vec3 color2 = rgb2hsb(color1);\n    color2.r += vDeg*0.5;\n    vec3 color3 = hsb2rgb(color2);\n    color3.r *= (sin(newUv.y)+1.)*0.5*0.75;\n\n    gl_FragColor = vec4(color3.xzy,1.0);\n}"},{"groupProps":{"position":[5.75,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"h","model":"H_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vNormal;\nuniform float time;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    newPos += normal*sin(time*2.5)*2.5;\n    vNormal = normal;\n    float a = sinTMap(1.5,0.15,0.45);\n\n    newPos.y += smoothstep(a,1.-a,sin(newPos.x*.05 - (sin(time*3.5)*2.))*cos(newPos.z*.05 + (cos(time*3.5)*2.)))*15.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color = abs(vNormal);\n    float l = dot(vNormal,vec3(cos(time*1.25)*sin(time*2.5),cos(time),sin(time)));\n    // color.xy *= newUv;\n    color.z = cos(newUv.x*5. + time);\n    vec3 finalColor = color*sin(l*15.);\n\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[7.75,3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"i","model":"I_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vMix;\nvarying vec3 vNormal;\nvarying float vNoise;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nvoid main() {\n    vUv = uv;\n    vNormal = normal;\n    vNoise = noise(vUv.x + time);\n    vec3 newPos = position;\n    //1 or sin..\n    float a = cosTMap(1.5,10.,75.);\n    float m = smoothstep(a-5.0,a+5.0,newPos.x);\n    vMix = m;\n    newPos.x *= mix(1.,sinTMap(2.5,1.0,2.0),m);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vMix;\nvarying vec3 vNormal;\nvarying float vNoise;\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 startColor = vec3(newUv.x,newUv.y,(sin(vNoise*5.)+1.)*0.5);\n\n    vec3 hsbStart = rgb2hsb(startColor);\n    hsbStart.r += vNormal.x;\n    hsbStart.g +=  (sin(newUv.y*vNormal.y + time)+1.0)*0.5;\n    // vec3 finalColor1 = mix(colora,,vMix*1.2);\n    // vec3 finalColor2 = mix(colora,hsb2rgb(hsbStart),vMix*0.8);\n    vec3 finalColor = hsb2rgb(hsbStart)*vMix;\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-8.25,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"j","model":"J_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvarying float vYValue;\nvarying float vxValue;\nvarying float vsValue;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float yValue = round(cnoise(newPos*0.1 + vec3(time*0.5))*1.2);\n    float xValue = step(sinTMap(1.5,-150.0,10.),newPos.z);\n    float s = smoothstep(0.0,1.0,(cos(time*5.)*sin(time) +1.0)*0.5);\n    vsValue = s;\n    newPos.y += yValue * 10. * s;\n    newPos.z += xValue * 10. * round(cnoise(newPos*0.25 + vec3(time*0.5))*1.2) * s;\n    vYValue = yValue;\n    vxValue = xValue;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\n\nvarying float vYValue;\nvarying float vxValue;\nvarying float vsValue;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color1 = vec3(vYValue,vxValue,newUv.x*newUv.y);\n    vec3 color2 = vec3(length(vec2(0.5,0.5)-newUv));\n    vec3 finalColor = mix(color1,color2,vsValue);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-6.25,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"k","model":"K_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vD;\nvarying float vD2;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n\n    vec3 diff = vec3(50.,0.,-50.) - newPos;\n    vec3 diff2 = vec3(65. + sin(time*1.5)*5.,0.,-75.) - newPos;\n    vec3 a = vec3(sin(time),0.,cos(time));\n    vec3 a2 = vec3(sin(time*2.5),0.,cos(-time*2.5));\n\n    float d = dot(normalize(diff),normalize(a));\n    float d2 = dot(normalize(diff2),normalize(a2));\n    vD = d;\n    vD2 = d2;\n\n    float b = sinTMap(2.5,0.0,1.0);\n    newPos.y += smoothstep(0.499 - b ,0.5 + b,d*d2)*15.;\n\n    vec3 finalPos = newPos;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying float vD;\nvarying vec2 vUv;\nvarying float vD2;\nvoid main() {\n    vec2 newUv = vUv;\n    float f = vD*vD2;\n\n    vec3 colorA = vec3(newUv.x,newUv.y,1. - newUv.x);\n    vec3 colorB = vec3(1. - newUv.y,newUv.x ,newUv.y);\n    gl_FragColor = vec4(mix(colorA,colorB,f),1.0);\n}"},{"groupProps":{"position":[-4.25,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"l","model":"L_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\nvoid main() {\n    vUv = uv;\n    vec3 newPos = position;\n\n    vec2 diff = vec2(75.,-75.) - newPos.xz;\n\n    float r = length(diff);\n    float deg = atan(diff.y,diff.x);\n    float f = 10. - round(sin(1.*deg + time*3.));\n\n    vR = r;\n    vDeg = deg;\n    vF = f;\n\n    newPos.y += f*7.5;\n    newPos.y -= 80.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\n\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    float fA = step(10.,vF);\n    vec3 color = vec3(fA);\n    vec3 colorA = vec3(newUv.x,newUv.y*(sin(vR + time*15.)*0.5+ 0.5),mod(1.5,vF)*vDeg);\n\n    vec3 colorB = rgb2hsb(colorA);\n    colorB.r += vDeg+sin(vR+time*0.5);\n    colorB.b *= (sin(vR+ time*0.5)+1.0)*0.5;\n    vec3 colorC = hsb2rgb(colorB);\n    gl_FragColor = vec4(colorC,1.0);\n}\n//Hacer que aumente/disminuir la posicion segun la diferencia de un vector y si esta dentro de cierta distancia"},{"groupProps":{"position":[-2.25,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"m","model":"M_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nvarying float vB;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float a = abs(newPos.z + sinTMap(2.5,-50.,250.0));\n    float b = 1. - step(45.,a);\n    vB = b;\n    newPos.x += b*sin(newPos.z*0.05)*15.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vB;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 defColor = vec3(length(vec2((sin(time)+1.0)*0.5,(cos(time)+1.0)*0.5) - newUv));\n    vec3 defColor2 = vec3(newUv.x,((sin((newUv.x)*12.5))+1.0)*0.5,newUv.y);\n    gl_FragColor = vec4(mix(defColor,defColor2,vB),1.0);\n}"},{"groupProps":{"position":[-0.25,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"n","model":"N_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vA;\nuniform float time;\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 defaultVec = vec2(75.,-75.);\n    vec2 diff = defaultVec - newPos.xz;\n    float a = 1.-smoothstep(0.,100.1 - ((sin(time*1.5)*sin(time*5.5))+1.0)*0.5*100.,length(diff));\n    vA = a;\n    // move space from the center to the vec2(0.0)\n    newPos.xz -= defaultVec;\n    // rotate the space\n    newPos.xz = rotate2d( cos(time*5.5)*sin(time*2.5)*max(1.0,length(diff/25.))*a ) * newPos.xz;\n    // move it back to the original place\n    newPos.xz += defaultVec;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\n#define PI 3.14159265359\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3((sin(time)+1.0)*0.5,newUv.x*newUv.y,newUv.y);\n    vec3 colorB = rgb2hsb(colorA);\n\n    colorB.r += PI;\n\n    gl_FragColor = vec4(mix(colorA,colorB,vA),1.0);\n}"},{"groupProps":{"position":[1.75,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"o","model":"O_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vA;\nuniform float time;\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 defaultVec = vec2(75.,5.0);\n    vec2 diff = defaultVec - newPos.xy;\n    float a = 1.-smoothstep(0.,100.1 - ((sin(time*1.5)*sin(time*5.5))+1.0)*0.5*100.,length(diff));\n    vA = a;\n    // move space from the center to the vec2(0.0)\n    newPos.xy -= defaultVec;\n    // rotate the space\n    newPos.xy = rotate2d(sin(time*2.5)*PI * a) * newPos.xy;\n    // move it back to the original place\n    newPos.xy += defaultVec;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\n\n#define PI 3.14159265359\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 defaultColor = vec3(newUv.x,newUv.y,(sin(vA)+1.0)*0.5);\n    vec3 defaultColorHSB = rgb2hsb(defaultColor);\n\n    defaultColorHSB.r += PI;\n    defaultColorHSB.g += sin(vA*PI)-0.5;\n\n    vec3 finalColor = mix(vec3(round(vA)),hsb2rgb(defaultColorHSB),sinTMap(1.5,0.5,1.0));\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[3.75,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"p","model":"P_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vValue;\n\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n\n    float scale = 0.05;\n    float v1 = sinTMap(2.5,0.15,2.5);\n    float value = smoothstep(0.0,1.0,cos((newPos.x*scale*v1 + sin(time)*15.))*sin(newPos.z*scale*v1 + cos(time)*15.));\n    vValue = value;\n    newPos.y += round(value)*15.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vValue;\n#define PI 3.14159265359\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3((cos(newUv.x)+1.0)*0.5,(sin(newUv.y)+1.0)*0.5,newUv.x*newUv.y);\n\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.r += 0.5+sin(vValue*PI*(sin(time*2.5)+1.0)*0.5)*0.15;\n\n    vec3 finalColor = mix(colorA,hsb2rgb(colorHSB),round(vValue));\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[5.75,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"q","model":"Q_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 diff = vec2(75.,-75.) - newPos.xz;\n\n    float r = length(diff);\n    float deg = atan(diff.y,diff.x);\n    float f = sin(max(sinTMap(0.5,-5.,12.5),1.0)*deg + time*3.);\n\n    vR = r;\n    vDeg = deg;\n    vF = f;\n\n    newPos.xz += normalize(diff)*f*sinTMap(1.5,-5.,15.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying float vR;\nvarying float vDeg;\nvarying float vF;\nvarying vec2 vUv;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n\n    vec3 colorA = vec3(vF,(sin(vR*0.25)+1.0)*0.5,newUv.x*newUv.y - vF*0.75);\n\n    vec3 colorAHSB = rgb2hsb(colorA);\n\n    colorAHSB.g += sin(vDeg)*1.5;\n\n    vec3 finalColor = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[7.75,1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"r","model":"R_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vA;\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 defaultVec = vec2(75.,5.0);\n    vec2 diff = defaultVec - newPos.xy;\n    float a = smoothstep(-150.,0.0,newPos.z + sin(time)*120.)*smoothstep(0.0,25. + (sin(time)+1.0)*0.5*75.,length(diff));\n    vA = a;\n    // move space from the center to the vec2(0.0)\n    newPos.xy -= defaultVec;\n    // rotate the space\n    newPos.xy = rotate2d(sin(time*2.5)*PI * a) * newPos.xy;\n    // move it back to the original place\n    newPos.xy += defaultVec;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.y,newUv.x,fract(sin(newUv.x*1.5 + time)*2.5));\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.r += 0.5;\n\n    vec3 finalColor = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-8.25,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"s","model":"S_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvarying float vA;\nvarying float vB;\nvarying float vC;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n// sinTMap(3.5,0.02,0.1)*sinTMap(5.5,0.5,0.75)\n    float xPoint = 50.;\n    float a =sin(newPos.z*0.05 + time);\n    float b = (smoothstep(0.0,50. + sin(time*2.5)*30.,80. - abs(xPoint - newPos.x)));\n    float c = cosTMap(1.35,0.0,1.0);\n\n    vA = a;\n    vB = b;\n    vC = c;\n\n    newPos.x += c*a*b*35.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\nvarying float vB;\nvarying float vC;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.x,vA*newUv.y,pow(vB,5.0));\n    vec3 colorHSB = rgb2hsb(colorA);\n\n    colorHSB.b *= pow(vB*newUv.y*1.25,3.0 + sin(time*2.5)*cos(time*3.5))+0.5;\n\n    vec3 finalColor = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(finalColor,1.0);\n}"},{"groupProps":{"position":[-6.25,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"t","model":"T_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\nvarying float vA;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float b = sinTMap(2.5,-80.,30.);\n    vec2 defaultVec = vec2(-20.,b-50.);\n    vec2 diff = defaultVec - newPos.xz;\n    // move space from the center to the vec2(0.0)\n    newPos.yz -= defaultVec;\n\n    float a = (1.0 -smoothstep(b-20.,b+20.,newPos.z));\n    vA = a;\n    // rotate the space\n    newPos.yz = rotate2d(PI*0.5*a)*newPos.yz;\n    // move it back to the original place\n    newPos.yz += defaultVec;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\n\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    float def = sinTMap(3.5,1.0,15.);//round optional\n    vec3 colorA = vec3(vec3(round(newUv.x*def)/def,round(sin(pow(length(newUv),2.0))*def)/def,round(newUv.y*def)/def));\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.r += 0.5;\n    vec3 colorB = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vA),1.0);\n}"},{"groupProps":{"position":[-4.25,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"u","model":"U_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\nvarying float vRot;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float b = cosTMap(1.75,0.,1.);\n    vec2 defaultVec = vec2(75.,0.);\n    vec2 diff = defaultVec - newPos.xy;\n    // move space from the center to the vec2(0.0)\n    newPos.xy -= defaultVec;\n\n    // rotate the space\n    float rotAmount = PI*sin(newPos.z*0.01 + time) + length(diff)*0.01;\n    vRot = rotAmount;\n    newPos.xy = rotate2d(rotAmount*b)*newPos.xy;\n    // move it back to the original place\n    newPos.xy += defaultVec;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vRot;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.x,newUv.y,pow(mod(1.0,newUv.x*newUv.y),sinTMap(2.5,0.25,0.75)));\n    vec3 colorB = vec3(pow(mod(1.0,newUv.x*newUv.y),sinTMap(2.5,0.25,0.75)),newUv.x,newUv.y);\n    gl_FragColor = vec4(mix(colorA,colorB,vRot),1.0);\n}"},{"groupProps":{"position":[-2.25,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"v","model":"V_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\nvarying float vyAdd;\nvarying float vyAdd2;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float yAdd = cos(newPos.z*0.05 + time*1.5);\n    float yAdd2 = mod(newPos.z,sinTMap(5.5,1.0,50.0))/25.;\n    vyAdd = yAdd;\n    vyAdd2 = yAdd2;\n    newPos.y += yAdd2*yAdd*12.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vyAdd;\nvarying float vyAdd2;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n\n    vec3 colorA = vec3(vyAdd2*newUv.x,newUv.y,newUv.x + newUv.y);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r += 0.5;\n    vec3 colorB = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,(vyAdd+1.0)*0.5),1.0);\n}"},{"groupProps":{"position":[-0.25,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"w","model":"W_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvarying float vVal;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float b = sinTMap(2.5,-80.,30.);\n    vec2 defaultVec = vec2(0.,-75.);\n    vec2 diff = defaultVec - newPos.yz;\n    // move space from the center to the vec2(0.0)\n    newPos.yz -= defaultVec;\n    // rotate the space\n    //*sin(newPos.x*0.005 + time)\n    float val = pow((sin(newPos.x*0.009 + time*2.5)+1.0)*0.5,6.0);\n    vVal = val;\n    newPos.yz = rotate2d(PI*0.7*val)*newPos.yz;\n    // move it back to the original place\n    newPos.yz += defaultVec;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVal;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n#define PI 3.14159265359\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(sin(newUv.x*PI),cos(newUv.x*PI),(newUv.x+newUv.y)*0.5);\n    float m = sinTMap(2.5,10.,25.);\n    colorA = round(colorA*m)/m;\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.r += 0.3;\n    vec3 colorB = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vVal),1.0);\n}"},{"groupProps":{"position":[1.75,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"x","model":"X_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vVal;\nvoid main() {\n    vUv = uv;\n    vec2 defaultVec = vec2(50.+cos(time*2.45)*50.,-50.+sin(time*2.45)*50.);\n    vec3 newPos = position;\n\n    vec2 diff = defaultVec - newPos.xz;\n\n    float sValue = (sin(length(diff)*0.15 + time*2.5)+1.0)*0.5;\n    vVal = sValue;\n    float a = 10.;\n    newPos.y += sValue*15.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVal;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.y,0.5,newUv.x);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r += sin(time);\n    vec3 colorB = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vVal),1.0);\n}"},{"groupProps":{"position":[3.75,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"y","model":"Y_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nvarying float vDisplace;\nvoid main() {\n    vUv = uv;\n    vec3 defaultVec = vec3(50.+sin(time*2.5)*25.,0.,-50. + cos(time*2.5)*25.);\n    vec3 newPos = position;\n    vec3 diff = defaultVec - newPos;\n    float disp = smoothstep(20.,60.,length(diff))*sin(time);\n    vDisplace = disp;\n    newPos+= normalize(diff)*25.0*disp;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vDisplace;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.y*newUv.y,newUv.x,newUv.x + newUv.y);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r += 0.7;\n    vec3 colorB = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vDisplace),1.0);\n}"},{"groupProps":{"position":[5.75,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"z","model":"Z_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vDist;\nvoid main() {\n    vUv = uv;\n    float zPos = -70.;\n    vec3 newPos = position;\n    float dist = zPos - newPos.z;\n    float val = smoothstep(40.,50.,abs(dist));\n    newPos.y += mix(0.5,2.25,val)*15.0*sin(time*2.5);\n    vDist = val;\n    newPos.x += pow(cos(newPos.z*0.05 + time*1.5)*sin(newPos.z*0.05 + time),3.0)*15.0;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vDist;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 color = vec3(1.-newUv.x,newUv.y+newUv.x,1.0);\n    vec3 colorHSB = rgb2hsb(color);\n    colorHSB.r += 0.5;\n    // colorHSB.b *= sin(round(length(newUv*5.0)));\n    vec3 colorB = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(mix(color,colorB,(1.0-vDist)+sinTMap(1.5,-0.5,0.5)),1.0);\n}"},{"groupProps":{"position":[7.75,-1.25,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"0","model":"0_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vVor;\n//\thttps://www.shadertoy.com/view/lsjGWD\n//\tby Pietro De Nicola\n//\n#define OCTAVES   \t\t1\t\t// 7\n#define SWITCH_TIME \t60.0\t\t// seconds\n\nfloat t()               {return (sin(time)+1.0)*0.5;}\nfloat function()        {return mod(t(),4.0);}\nbool  multiply_by_F1()  {return mod(t(),8.0)  >= 4.0;}\nbool  inversef()         {return mod(t(),16.0) >= 8.0;}\nfloat distance_type()\t{return mod(t()/16.0,4.0);}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat voronoi( in vec2 x ){\n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tfloat F1 = 8.0;\n\tfloat F2 = 8.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t\tfor( int i=-1; i<=1; i++ ){\n\t\t\tvec2 g = vec2(i,j);\n\t\t\tvec2 o = hash( n + g );\n\n\t\t\to = 0.5 + 0.41*sin( time + 6.2831*o );\n\t\t\tvec2 r = g - f + o;\n\n\t\tfloat d = \tdistance_type() < 1.0 ? dot(r,r)  :\t\t\t\t// euclidean^2\n\t\t\t\t  \tdistance_type() < 2.0 ? sqrt(dot(r,r)) :\t\t\t// euclidean\n\t\t\t\t\tdistance_type() < 3.0 ? abs(r.x) + abs(r.y) :\t\t// manhattan\n\t\t\t\t\tdistance_type() < 4.0 ? max(abs(r.x), abs(r.y)) :\t// chebyshev\n\t\t\t\t\t0.0;\n\n\t\tif( d<F1 ) {\n\t\t\tF2 = F1;\n\t\t\tF1 = d;\n\t\t} else if( d<F2 ) {\n\t\t\tF2 = d;\n\t\t}\n    }\n\n\tfloat c = function() < 1.0 ? F1 :\n\t\t\t  function() < 2.0 ? F2 :\n\t\t\t  function() < 3.0 ? F2-F1 :\n\t\t\t  function() < 4.0 ? (F1+F2)/2.0 :\n\t\t\t  0.0;\n\n\tif( multiply_by_F1() )\tc *= F1;\n\tif( inversef() )\t\t\tc = 1.0 - c;\n\n    return c;\n}\n\nfloat fbm( in vec2 p ){\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\n\tfor( int i=0; i<OCTAVES; i++ ){\n\t\ts += a * voronoi(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s/m;\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float vor = voronoi(newPos.xz*0.05);\n    vVor = vor;\n    newPos.y += vor*15.0;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVor;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA =vec3(newUv.x,newUv.y,0.35);\n    vec3 colorB =vec3(newUv.y,newUv.y*newUv.x,(sin(newUv.y+newUv.x + time)+1.0)*0.5);\n    gl_FragColor = vec4(mix(colorA,colorB,vVor),1.0);\n}"},{"groupProps":{"position":[-8.25,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"1","model":"1_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vVor;\n//\thttps://www.shadertoy.com/view/lsjGWD\n//\tby Pietro De Nicola\n//\n#define OCTAVES   \t\t1\t\t// 7\n#define SWITCH_TIME \t60.0\t\t// seconds\n\nfloat t()               {return 0.5;}\nfloat function()        {return mod(t(),4.0);}\nbool  multiply_by_F1()  {return mod(t(),8.0)  >= 4.0;}\nbool  inversef()         {return mod(t(),16.0) >= 8.0;}\nfloat distance_type()\t{return mod(t()/16.0,4.0);}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat voronoi( in vec2 x ){\n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tfloat F1 = 8.0;\n\tfloat F2 = 8.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t\tfor( int i=-1; i<=1; i++ ){\n\t\t\tvec2 g = vec2(i,j);\n\t\t\tvec2 o = hash( n + g );\n\n\t\t\to = 0.5 + 0.41*sin( time + 6.2831*o );\n\t\t\tvec2 r = g - f + o;\n\n\t\tfloat d = \tdistance_type() < 1.0 ? dot(r,r)  :\t\t\t\t// euclidean^2\n\t\t\t\t  \tdistance_type() < 2.0 ? sqrt(dot(r,r)) :\t\t\t// euclidean\n\t\t\t\t\tdistance_type() < 3.0 ? abs(r.x) + abs(r.y) :\t\t// manhattan\n\t\t\t\t\tdistance_type() < 4.0 ? max(abs(r.x), abs(r.y)) :\t// chebyshev\n\t\t\t\t\t0.0;\n\n\t\tif( d<F1 ) {\n\t\t\tF2 = F1;\n\t\t\tF1 = d;\n\t\t} else if( d<F2 ) {\n\t\t\tF2 = d;\n\t\t}\n    }\n\n\tfloat c = function() < 1.0 ? F1 :\n\t\t\t  function() < 2.0 ? F2 :\n\t\t\t  function() < 3.0 ? F2-F1 :\n\t\t\t  function() < 4.0 ? (F1+F2)/2.0 :\n\t\t\t  0.0;\n\n\tif( multiply_by_F1() )\tc *= F1;\n\tif( inversef() )\t\t\tc = 1.0 - c;\n\n    return c;\n}\n\nfloat fbm( in vec2 p ){\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\n\tfor( int i=0; i<OCTAVES; i++ ){\n\t\ts += a * voronoi(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s/m;\n}\n\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float vor = voronoi(newPos.xz*(0.01 + (sin(time*2.5)+1.0)*0.5*0.005) + time);\n    vor = pow(1.-vor,2.0);\n    vVor = vor;\n    newPos.y += vor*15.0;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVor;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.x,0.25,newUv.y);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r += 0.3;\n    vec3 colorB = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vVor),1.0);\n}"},{"groupProps":{"position":[-6.25,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"2","model":"2_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n// vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\nvarying float vVar;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float n = cnoise(newPos.xz*0.1+ time);\n    vVar = n;\n    newPos.y += n*15.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.x,newUv.y*newUv.x,0.25);\n    vec3 colorB = vec3((cos(time*3.5)+1.0)*0.5);\n    gl_FragColor = vec4(mix(colorA,colorB,pow(vVar+(sin(time)+1.0)*0.5,0.5)),1.0);\n}"},{"groupProps":{"position":[-4.25,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"3","model":"3_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n// vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvarying float vVar;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 defaultVec = vec2(50.,-75.);\n\n    float n = cnoise(rotate2d(sin(time*0.5)*PI)*(newPos.xz-defaultVec)*0.08);\n    vVar = n;\n    newPos.y += n*15.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\n/* Easing Expo In equation */\n/* Adapted from Robert Penner easing equations */\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n\n    vec3 colorA = vec3(newUv.x,0.5+sin(time)*0.15,newUv.y);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r+=0.2;\n    colorAHSB.g+=0.2;\n    vec3 colorB = hsb2rgb(colorAHSB);\n\n    gl_FragColor = vec4(mix(colorA,colorB,vVar),1.0);\n}"},{"groupProps":{"position":[-2.25,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"4","model":"4_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n#define OCTAVES   \t\t1\t\t// 7\n#define SWITCH_TIME \t60.0\t\t// seconds\n\nfloat t()               {return (sin(time)+1.0)*0.5;}\nfloat function()        {return mod(t(),4.0);}\nbool  multiply_by_F1()  {return mod(t(),8.0)  >= 4.0;}\nbool  inversef()         {return mod(t(),16.0) >= 8.0;}\nfloat distance_type()\t{return mod(t()/16.0,4.0);}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat voronoi( in vec2 x ){\n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tfloat F1 = 8.0;\n\tfloat F2 = 8.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t\tfor( int i=-1; i<=1; i++ ){\n\t\t\tvec2 g = vec2(i,j);\n\t\t\tvec2 o = hash( n + g );\n\n\t\t\to = 0.5 + 0.41*sin( time + 6.2831*o );\n\t\t\tvec2 r = g - f + o;\n\n\t\tfloat d = \tdistance_type() < 1.0 ? dot(r,r)  :\t\t\t\t// euclidean^2\n\t\t\t\t  \tdistance_type() < 2.0 ? sqrt(dot(r,r)) :\t\t\t// euclidean\n\t\t\t\t\tdistance_type() < 3.0 ? abs(r.x) + abs(r.y) :\t\t// manhattan\n\t\t\t\t\tdistance_type() < 4.0 ? max(abs(r.x), abs(r.y)) :\t// chebyshev\n\t\t\t\t\t0.0;\n\n\t\tif( d<F1 ) {\n\t\t\tF2 = F1;\n\t\t\tF1 = d;\n\t\t} else if( d<F2 ) {\n\t\t\tF2 = d;\n\t\t}\n    }\n\n\tfloat c = function() < 1.0 ? F1 :\n\t\t\t  function() < 2.0 ? F2 :\n\t\t\t  function() < 3.0 ? F2-F1 :\n\t\t\t  function() < 4.0 ? (F1+F2)/2.0 :\n\t\t\t  0.0;\n\n\tif( multiply_by_F1() )\tc *= F1;\n\tif( inversef() )\t\t\tc = 1.0 - c;\n\n    return c;\n}\n\nfloat fbm( in vec2 p ){\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\n\tfor( int i=0; i<OCTAVES; i++ ){\n\t\ts += a * voronoi(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s/m;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvarying float vVar;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 defaultVec = vec2(50.,-75.);\n\n    float n = voronoi(rotate2d(sin(time*0.5)*PI)*(newPos.xz-defaultVec)*0.05);\n    vVar = n;\n    newPos.y += n*15.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\n/* Easing Expo In equation */\n/* Adapted from Robert Penner easing equations */\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n\n    vec3 colorA = vec3(pow(newUv.x,1.5),0.55+sin(time)*0.15,newUv.y);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.gb*=sinTMap(2.5,-2.,-0.5);\n\n    vec3 colorB = hsb2rgb(colorAHSB);\n\n    gl_FragColor = vec4(mix(colorA,colorB,vVar),1.0);\n}"},{"groupProps":{"position":[-0.25,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"5","model":"5_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\n\t// Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// This one has non-ideal tiling properties that I'm still tuning\nfloat noise(vec3 x) {\n\tconst vec3 step = vec3(110, 241, 171);\n\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n \n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the \n\t// incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nvarying float vVar;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    vec2 v = vec2(sin(time),cos(time));\n    float n = noise(newPos.xz*0.05 + v);\n    vVar = n;\n    newPos.y += n*25.;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    float a = round(sinTMap(2.5,10.,25.));\n    float b = round(vVar*a)/a;\n\n    vec3 colorA = vec3(sinTMap(1.5,0.0,1.0),newUv.y,0.5);\n    vec3 colorAHSB = rgb2hsb(colorA);\n    colorAHSB.r += 0.15*round(length(vec2(sin(time),cos(time))-newUv)*25.)/25.;\n    colorAHSB.b *= sin(a*b);\n    vec3 colorB = hsb2rgb(colorAHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,b),1.0);\n}"},{"groupProps":{"position":[1.75,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"6","model":"6_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\nvarying float vVar;\nvoid main() {\n    vUv = uv;\n    vec2 defaultVec = vec2(70.,-50.);\n    vec3 newPos = position;\n    vec2 diff = defaultVec - newPos.xz;\n    float x = round((length(diff*(sin(time*2.5)*0.01)))*10.0)/10.0;\n    vVar = x;\n    newPos.y += pow(x+0.15,3.0)*55.*sin(time*2.5);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    float a = sinTMap(1.0,0.0,1.0);\n    float a2 = sinTMap(1.5,0.0,1.0);\n    float b = cosTMap(1.0,0.0,1.0);\n    float b2 = cosTMap(1.35,0.0,1.0);\n    vec2 defaultVec1 = vec2(a,b);\n    vec2 defaultVec2 = vec2(b,a);\n    vec2 defaultVec3 = vec2(-a2,b2);\n\n    vec3 colorA = vec3(length(newUv-defaultVec1),length(newUv-defaultVec2),length(newUv-defaultVec3));\n\n    vec3 colorHSB = hsb2rgb(colorA);\n\n    colorHSB.r += vVar;\n\n    vec3 colorB = hsb2rgb(colorHSB);\n\n    // vec3 colorA = vec3();\n    gl_FragColor = vec4(mix(colorA,colorB,vVar),1.0);\n}"},{"groupProps":{"position":[3.75,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"7","model":"7_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n#define OCTAVES 5\t\t// 7\n\nfloat t()               {return (sin(0.5)+1.0)*0.5;}\nfloat function()        {return mod(t(),4.0);}\nbool  multiply_by_F1()  {return mod(t(),8.0)  >= 4.0;}\nbool  inversef()         {return mod(t(),16.0) >= 8.0;}\nfloat distance_type()\t{return mod(t()/16.0,4.0);}\n\nvec2 hash( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat voronoi( in vec2 x ){\n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tfloat F1 = 8.0;\n\tfloat F2 = 8.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t\tfor( int i=-1; i<=1; i++ ){\n\t\t\tvec2 g = vec2(i,j);\n\t\t\tvec2 o = hash( n + g );\n\n\t\t\to = 0.5 + 0.41*sin(time + 6.2831*o );\n\t\t\tvec2 r = g - f + o;\n\n\t\tfloat d = \tdistance_type() < 1.0 ? dot(r,r)  :\t\t\t\t// euclidean^2\n\t\t\t\t  \tdistance_type() < 2.0 ? sqrt(dot(r,r)) :\t\t\t// euclidean\n\t\t\t\t\tdistance_type() < 3.0 ? abs(r.x) + abs(r.y) :\t\t// manhattan\n\t\t\t\t\tdistance_type() < 4.0 ? max(abs(r.x), abs(r.y)) :\t// chebyshev\n\t\t\t\t\t0.0;\n\n\t\tif( d<F1 ) {\n\t\t\tF2 = F1;\n\t\t\tF1 = d;\n\t\t} else if( d<F2 ) {\n\t\t\tF2 = d;\n\t\t}\n    }\n\n\tfloat c = function() < 1.0 ? F1 :\n\t\t\t  function() < 2.0 ? F2 :\n\t\t\t  function() < 3.0 ? F2-F1 :\n\t\t\t  function() < 4.0 ? (F1+F2)/2.0 :\n\t\t\t  0.0;\n\n\tif( multiply_by_F1() )\tc *= F1;\n\tif( inversef() )\t\t\tc = 1.0 - c;\n\n    return c;\n}\n\nfloat fbm( in vec2 p ){\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\n\tfor( int i=0; i<OCTAVES; i++ ){\n\t\ts += a * voronoi(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s/m;\n}\n\nvarying float vVar;\nvarying float vVar2;\nvoid main() {\n    vUv = uv;\n\n    vec3 newPos = position;\n    float vor = voronoi(newPos.xz*0.05);\n    // vVar = vor;\n    newPos.y += vor*25.0;\n    float x = sin(newPos.z*0.05 + time*2.25);\n    vVar2 = x;\n    newPos.x += x*10.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vVar;\nvarying float vVar2;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    float a = sinTMap(1.0,4.0,15.0);\n    float b = sinTMap(1.0,4.0,18.0);\n\n    vec3 colorA = vec3(round(sinTMap(2.25,0.0,1.0)*newUv.y*15.)/15.,round(sinTMap(2.75,0.0,1.0)*newUv.x*10.)/10.,newUv.x);\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.b+= pow(((sin(time)+1.0)*0.5)+0.2,3. + vVar);\n    colorHSB.r+= 0.5;\n    vec3 colorB = hsb2rgb(colorHSB);\n// vec3(round(vVar*a)/b\n    gl_FragColor = vec4(mix(colorA,colorB,vVar*0.85 +  (round((vVar2+1.0)*0.5*10.)/10.)*0.5),1.0);\n}"},{"groupProps":{"position":[5.75,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"8","model":"8_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\n#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvarying float vA;\nvarying float vB;\nvarying float vM;\nvoid main() {\n    vUv = uv;\n    vec2 def1 = vec2(-35.,-75.);\n    float xdif = 75.;\n    vec3 newPos = position;\n    newPos.xz -= def1;\n    float b = cos(time);\n    newPos.xz *= rotate2d(-PI/6. + b*0.2);\n\n    newPos.x -= xdif;\n    float a = sin(time);\n    newPos.xy *= rotate2d(newPos.z*0.05*a);\n\n    vA = a;\n    vB = b;\n    newPos.x += xdif;\n    newPos.xz *= rotate2d(PI/6.);\n    newPos.xz += def1;\n    float k = sinTMap(2.5,-225.,0.);\n    float m = smoothstep(k-15.,k+15.,position.z);\n    vM = m;\n    vec3 finalPos = mix(newPos,position,m);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvarying float vA;\nvarying float vB;\nvarying float vM;\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(max(0.5,vA)*newUv.x,max(vB,0.5)*newUv.y,0.15);\n    vec3 colorHSB = rgb2hsb(colorA);\n    colorHSB.b *= (sin(newUv.x + newUv.y)+1.0)*0.5;\n    colorHSB.r += 0.15;\n    vec3 colorB = hsb2rgb(colorHSB);\n    gl_FragColor = vec4(mix(colorA,colorB,vM),1.0);\n}"},{"groupProps":{"position":[7.75,-3.75,0],"rotation":[0,0,0],"scale":[1,1,1]},"letter":"9","model":"9_Letter.glb","vertexShader":"#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float time;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\nvarying float vA;\nvarying float vL;\nvoid main() {\n    vUv = uv;\n    vec2 defVec= vec2(65.,-105.);\n    vec3 newPos = position;\n    vec2 diff = defVec - newPos.xz;\n    float k = sinTMap(2.5,0.0,110.);\n    float a = smoothstep(k-10.,k+10.,length(diff));\n    vL = length(diff);\n    vA = a;\n    newPos.y += sin(length(diff)*0.5 + time)*a*15.;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );\n}","fragmentShader":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vA;\nvarying float vL;\nvoid main() {\n    vec2 newUv = vUv;\n    vec3 colorA = vec3(newUv.x,newUv.y,sin(vL*0.5 - time*2.5));\n    vec3 colorB = vec3(sin(vL*0.5 + time*2.5));\n    gl_FragColor = vec4(mix(colorA,colorB,vA),1.0);\n}"}]}},"__N_SSG":true}