{"pageProps":{"page":{"previous":"e","next":"g","letter":"f","vertex":"#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vYValue;\nvarying float vSmSt;\nuniform float time;\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vUv = uv;\n    vec3 newPos = position;\n\n    vec2 ref = newPos.xz;\n    ref.x += cos(time*5.)*15.;\n    ref.y += sin(time*5.)*15.;\n\n    vec2 diff = ref - vec2(75.,-75.);\n\n    float yValue = sin(length(diff)*0.5 + time*10.0)*5.0 - length(diff)*sin(time*10.)*0.15;\n    vYValue = yValue;\n\n    float s = smoothstep((50.+sin(time*1.75)*50.)-3.,(50.+sin(time*1.75)*50.)+3.,newPos.x);\n    vSmSt = s;\n    newPos.y += s*yValue;\n\n    vec3 finalPos = newPos;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n}\n\n// void main() {\n//     vUv = uv;\n//     vec3 newPos = position;\n\n//     vec2 ref = newPos.xz;\n//     ref.x += cos(time*5.)*15.;\n//     ref.y += sin(time*5.)*15.;\n\n//     vec2 diff = ref - vec2(75.,-75.);\n//     vec3 newPosNormalized = normalize(newPos);\n\n//     float yValue = sin(length(diff)*0.5 + time*10.0)*5.0 - length(diff)*sin(time*10.)*0.15;\n\n//     float v1 = mod(1.+sin(time*1.75)*1.,newPos.x)*1.5;\n//     float v2 = step(50.+sin(time*1.75)*50.,newPos.x)*1.5;\n//     newPos.y += smoothstep(0.,1.,mix(v1,v2,abs(newPosNormalized.z)))*yValue;\n\n//     vec3 finalPos = newPos;\n\n//     gl_Position = projectionMatrix * modelViewMatrix * vec4( finalPos, 1.0 );\n// }","frag":"#define GLSLIFY 1\nuniform float time;\nvarying vec2 vUv;\nvarying float vYValue;\nvarying float vSmSt;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat sinT(float f){\n    return sin(time*f);\n}\nfloat sinTMap(float f,float min, float max){\n    return map(sin(time*f),-1.,1.,min,max);\n}\n\nfloat cosT(float f){\n    return cos(time*f);\n}\nfloat cosTMap(float f,float min, float max){\n    return map(cos(time*f),-1.,1.,min,max);\n}\n\nvoid main() {\n    vec2 newUv = vUv;\n    vec2 diff = newUv - vec2(sin(time*5.)*0.15 +.5,cos(time*5.)*0.15 + .5);\n\n    float a=length(diff)*sinTMap(1.5,0.05,0.25)*vYValue;\n    float b=newUv.y*sinTMap(newUv.x*80.5,cos(time),1.);\n    float c=cosTMap(2.5*mod(newUv.x,time),0.0,1.0);\n    vec3 col = vec3(a,c*b,b);\n    float w1=sinTMap(2.5,0.0,1.0)*newUv.y;\n    float w2=(dot(vec2(sin(time*2.5),cos(time*2.5)),newUv)+1.0)*0.5;\n    float w3=length(newUv)*newUv.x;\n    vec3 w = vec3(w2,w1,w3);\n    vec3 finalColor = mix(w,col,vSmSt);\n    gl_FragColor = vec4(finalColor,1.0);\n}","model":"F_Letter.glb","positionOffset":[0,0,0],"scale":1}},"__N_SSG":true}